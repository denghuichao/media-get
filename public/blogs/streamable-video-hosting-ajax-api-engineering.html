<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamable Video Hosting Engineering: Ajax API Integration & Multi-Format Processing</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            color: #34495e;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-top: 30px;
        }

        h3 {
            color: #16a085;
            margin-top: 25px;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            border-left: 4px solid #667eea;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            line-height: 1.5;
        }

        /* Syntax Highlighting for Python code */
        .code-block .keyword {
            color: #569cd6;
        }

        .code-block .string {
            color: #ce9178;
        }

        .code-block .comment {
            color: #6a9955;
        }

        .code-block .function {
            color: #dcdcaa;
        }

        .code-block .variable {
            color: #9cdcfe;
        }

        .code-block .number {
            color: #b5cea8;
        }

        .code-block .constant {
            color: #4fc1ff;
        }

        .code-block .class {
            color: #4ec9b0;
        }

        .code-block .property {
            color: #9cdcfe;
        }

        .code-block .operator {
            color: #d4d4d4;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .info-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #f39c12;
        }

        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f2f2f2;
        }

        .architecture-diagram {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .flow-step {
            background: #667eea;
            color: white;
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
            display: inline-block;
            min-width: 200px;
        }

        .arrow {
            font-size: 20px;
            color: #667eea;
            margin: 0 10px;
        }

        ul li {
            margin: 8px 0;
        }

        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .tech-item {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .status-badge {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            display: inline-block;
            margin: 5px;
        }

        .blog-navigation {
            margin: 20px 0;
            text-align: center;
        }

        .blog-index-link {
            display: inline-block;
            padding: 10px 20px;
            background-color: #85C341;
            color: white;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .blog-index-link:hover {
            background-color: #6c9a33;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üé¨ Streamable Video Hosting Engineering: Ajax API Integration & Multi-Format Processing</h1>
        <div class="blog-navigation">
            <a href="/#blogs" class="blog-index-link">‚Üê Back to Blog Index</a>
        </div>


        <div class="highlight">
            <strong>Overview:</strong> This comprehensive analysis explores Streamable's video hosting platform
            extraction in yt-dlp, focusing on Ajax API integration, multi-format processing, upload status handling, and
            efficient codec detection. Streamable represents a modern approach to simple video hosting with
            sophisticated backend processing.
        </div>

        <div class="status-badge">Ajax API</div>
        <div class="status-badge">Multi-Format</div>
        <div class="status-badge">Upload Processing</div>
        <div class="status-badge">Codec Detection</div>
        <div class="status-badge">Reddit Integration</div>

        <h2>üèóÔ∏è Streamable Architecture Overview</h2>

        <div class="architecture-diagram">
            <h3>yt-dlp Streamable Processing Pipeline</h3>
            <div class="flow-step">URL Validation & ID Extraction</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Ajax API Request</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Upload Status Verification</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Multi-Format Discovery</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Codec & Quality Analysis</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Metadata Enrichment</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Format Selection & Delivery</div>
        </div>

        <h2>üîß Core Implementation Analysis</h2>

        <h3>1. Ajax API Integration Strategy</h3>
        <p>Streamable uses an internal Ajax API rather than a public API for better reliability and data completeness:
        </p>

        <div class="code-block">
            <span class="keyword">def</span> <span class="function">_real_extract</span>(<span
                class="variable">self</span>, <span class="variable">url</span>):
            <span class="variable">video_id</span> = <span class="variable">self</span>.<span
                class="function">_match_id</span>(<span class="variable">url</span>)

            <span class="comment"># Note: Using the ajax API, as the public Streamable API doesn't seem</span>
            <span class="comment"># to return video info like the title properly sometimes, and doesn't</span>
            <span class="comment"># include info like the video duration</span>
            <span class="variable">video</span> = <span class="variable">self</span>.<span
                class="function">_download_json</span>(
            <span class="string">f'https://ajax.streamable.com/videos/{video_id}'</span>, <span
                class="variable">video_id</span>)
        </div>

        <div class="info-box">
            <strong>API Strategy:</strong> The implementation deliberately chooses the Ajax API over the public API due
            to more complete metadata including duration, better title handling, and more reliable video information.
        </div>

        <h3>2. Upload Status Management System</h3>
        <p>Streamable implements a sophisticated status system to handle video processing states:</p>

        <div class="code-block">
            <span class="comment"># Format IDs:</span>
            <span class="comment"># 0 The video is being uploaded</span>
            <span class="comment"># 1 The video is being processed</span>
            <span class="comment"># 2 The video has at least one file ready</span>
            <span class="comment"># 3 The video is unavailable due to an error</span>
            <span class="variable">status</span> = <span class="variable">video</span>.<span
                class="function">get</span>(<span class="string">'status'</span>)
            <span class="keyword">if</span> <span class="variable">status</span> != <span class="number">2</span>:
            <span class="keyword">raise</span> <span class="function">ExtractorError</span>(
            <span class="string">'This video is currently unavailable. It may still be uploading or processing.'</span>,
            <span class="variable">expected</span>=<span class="constant">True</span>)
        </div>

        <table>
            <thead>
                <tr>
                    <th>Status Code</th>
                    <th>Description</th>
                    <th>User Experience</th>
                    <th>Technical Action</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td>Being uploaded</td>
                    <td>Please wait</td>
                    <td>Block extraction</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>Being processed</td>
                    <td>Processing in progress</td>
                    <td>Block extraction</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>At least one file ready</td>
                    <td>Available for download</td>
                    <td>Proceed with extraction</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Unavailable due to error</td>
                    <td>Video unavailable</td>
                    <td>Error reporting</td>
                </tr>
            </tbody>
        </table>

        <h3>3. Multi-Format Processing Engine</h3>
        <p>Streamable provides multiple format variants with detailed technical metadata:</p>

        <div class="code-block">
            <span class="variable">formats</span> = []
            <span class="keyword">for</span> <span class="variable">key</span>, <span class="variable">info</span> <span
                class="keyword">in</span> <span class="variable">video</span>[<span class="string">'files'</span>].<span
                class="function">items</span>():
            <span class="keyword">if not</span> <span class="variable">info</span>.<span
                class="function">get</span>(<span class="string">'url'</span>):
            <span class="keyword">continue</span>
            <span class="variable">formats</span>.<span class="function">append</span>({
            <span class="string">'format_id'</span>: <span class="variable">key</span>,
            <span class="string">'url'</span>: <span class="variable">self</span>.<span
                class="function">_proto_relative_url</span>(<span class="variable">info</span>[<span
                class="string">'url'</span>]),
            <span class="string">'width'</span>: <span class="function">int_or_none</span>(<span
                class="variable">info</span>.<span class="function">get</span>(<span class="string">'width'</span>)),
            <span class="string">'height'</span>: <span class="function">int_or_none</span>(<span
                class="variable">info</span>.<span class="function">get</span>(<span class="string">'height'</span>)),
            <span class="string">'filesize'</span>: <span class="function">int_or_none</span>(<span
                class="variable">info</span>.<span class="function">get</span>(<span class="string">'size'</span>)),
            <span class="string">'fps'</span>: <span class="function">int_or_none</span>(<span
                class="variable">info</span>.<span class="function">get</span>(<span
                class="string">'framerate'</span>)),
            <span class="string">'vbr'</span>: <span class="function">float_or_none</span>(<span
                class="variable">info</span>.<span class="function">get</span>(<span class="string">'bitrate'</span>),
            <span class="number">1000</span>),
            <span class="string">'vcodec'</span>: <span class="function">parse_codecs</span>(<span
                class="function">try_get</span>(<span class="variable">info</span>, <span class="keyword">lambda</span>
            <span class="variable">x</span>: <span class="variable">x</span>[<span
                class="string">'input_metadata'</span>][<span class="string">'video_codec_name'</span>])).<span
                class="function">get</span>(<span class="string">'vcodec'</span>),
            <span class="string">'acodec'</span>: <span class="function">parse_codecs</span>(<span
                class="function">try_get</span>(<span class="variable">info</span>, <span class="keyword">lambda</span>
            <span class="variable">x</span>: <span class="variable">x</span>[<span
                class="string">'input_metadata'</span>][<span class="string">'audio_codec_name'</span>])).<span
                class="function">get</span>(<span class="string">'acodec'</span>),
            })
        </div>

        <h2>üìä Advanced Codec Detection</h2>

        <h3>Intelligent Codec Parsing</h3>
        <p>The system extracts detailed codec information from metadata with fallback handling:</p>

        <div class="code-block">
            # Video codec detection
            'vcodec': parse_codecs(try_get(info, lambda x: x['input_metadata']['video_codec_name'])).get('vcodec'),

            # Audio codec detection
            'acodec': parse_codecs(try_get(info, lambda x: x['input_metadata']['audio_codec_name'])).get('acodec'),
        </div>

        <div class="info-box">
            <strong>Codec Robustness:</strong> The try_get() function ensures safe access to nested metadata structures,
            preventing extraction failures when codec information is missing or malformed.
        </div>

        <h2>üéØ URL Pattern Recognition</h2>

        <table>
            <thead>
                <tr>
                    <th>URL Type</th>
                    <th>Pattern</th>
                    <th>Example</th>
                    <th>Processing Method</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Standard Video</td>
                    <td>/video_id</td>
                    <td>streamable.com/dnd1</td>
                    <td>Direct ID extraction</td>
                </tr>
                <tr>
                    <td>Embedded Video</td>
                    <td>/e/video_id</td>
                    <td>streamable.com/e/dnd1</td>
                    <td>Embed path handling</td>
                </tr>
                <tr>
                    <td>Spanish Interface</td>
                    <td>/es/video_id</td>
                    <td>streamable.com/es/dnd1</td>
                    <td>Language prefix support</td>
                </tr>
                <tr>
                    <td>Share URLs</td>
                    <td>/s/id/token</td>
                    <td>streamable.com/s/okkqk/drxjds</td>
                    <td>Share link processing</td>
                </tr>
                <tr>
                    <td>Embed iframes</td>
                    <td>iframe src attribute</td>
                    <td>HTML embed detection</td>
                    <td>Regex extraction</td>
                </tr>
            </tbody>
        </table>

        <h3>Flexible URL Handling</h3>

        <div class="code-block">
            _VALID_URL = r'https?://streamable\.com/(?:[es]/)?(?P<id>\w+)'
                _EMBED_REGEX =
                [r'<iframe[^>]+\bsrc=(?P<q1>[\'"])(?P<url>(?:https?:)?//streamable\.com/.+?)(?P=q1)']
        </div>

        <h2>üé¨ Metadata Processing Excellence</h2>

        <h3>Intelligent Title Selection</h3>
        <p>Streamable prioritizes Reddit titles for social media integration:</p>

        <div class="code-block">
            title = video.get('reddit_title') or video['title']
        </div>

        <div class="success-box">
            <strong>Social Integration:</strong> The preference for reddit_title reflects Streamable's strong
            integration with Reddit communities, providing more contextual and descriptive titles.
        </div>

        <h3>Comprehensive Metadata Extraction</h3>

        <div class="code-block">
            return {
            'id': video_id,
            'title': title,
            'description': video.get('description'),
            'thumbnail': self._proto_relative_url(video.get('thumbnail_url')),
            'uploader': video.get('owner', {}).get('user_name'),
            'timestamp': float_or_none(video.get('date_added')),
            'duration': float_or_none(video.get('duration')),
            'view_count': int_or_none(video.get('plays')),
            'formats': formats,
            }
        </div>

        <h2>üîß Technical Quality Features</h2>

        <div class="tech-stack">
            <div class="tech-item">
                <h4>üìê Format Quality Analysis</h4>
                <p>Width, height, framerate, and bitrate extraction for optimal format selection</p>
            </div>
            <div class="tech-item">
                <h4>üìä File Size Intelligence</h4>
                <p>Precise file size information for bandwidth planning and download estimation</p>
            </div>
            <div class="tech-item">
                <h4>üéµ Audio/Video Codec Detection</h4>
                <p>Detailed codec parsing from input metadata for compatibility assessment</p>
            </div>
            <div class="tech-item">
                <h4>üîó Protocol Relative URLs</h4>
                <p>Smart URL handling for both HTTP and HTTPS compatibility</p>
            </div>
        </div>

        <h2>üìà Performance Optimizations</h2>

        <h3>1. Efficient Single API Call</h3>
        <div class="success-box">
            <strong>API Efficiency:</strong> The entire extraction process requires only one API call to retrieve all
            necessary video information, metadata, and format details.
        </div>

        <h3>2. Safe Metadata Access</h3>
        <div class="code-block">
            # Safe nested access with fallback
            'uploader': video.get('owner', {}).get('user_name'),

            # Robust codec extraction
            'vcodec': parse_codecs(try_get(info, lambda x: x['input_metadata']['video_codec_name'])).get('vcodec'),
        </div>

        <h2>‚ö° Error Handling & Edge Cases</h2>

        <table>
            <thead>
                <tr>
                    <th>Error Scenario</th>
                    <th>Detection Method</th>
                    <th>Handling Strategy</th>
                    <th>User Experience</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Video Uploading</td>
                    <td>Status code 0</td>
                    <td>Informative error message</td>
                    <td>Wait notification</td>
                </tr>
                <tr>
                    <td>Video Processing</td>
                    <td>Status code 1</td>
                    <td>Processing notification</td>
                    <td>Retry suggestion</td>
                </tr>
                <tr>
                    <td>Processing Error</td>
                    <td>Status code 3</td>
                    <td>Unavailable error</td>
                    <td>Error explanation</td>
                </tr>
                <tr>
                    <td>Missing Formats</td>
                    <td>Empty files object</td>
                    <td>No formats available</td>
                    <td>Format unavailable notice</td>
                </tr>
                <tr>
                    <td>Invalid Video ID</td>
                    <td>API error response</td>
                    <td>Video not found</td>
                    <td>URL verification help</td>
                </tr>
            </tbody>
        </table>

        <h3>Robust Status Handling</h3>

        <div class="warning-box">
            <strong>Processing States:</strong> Streamable's processing pipeline can take time, especially for large
            videos. The status system ensures users understand when content is temporarily unavailable versus
            permanently inaccessible.
        </div>

        <h2>üé• Format Quality Matrix</h2>

        <table>
            <thead>
                <tr>
                    <th>Format Attribute</th>
                    <th>Data Source</th>
                    <th>Processing Method</th>
                    <th>Quality Impact</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Resolution</td>
                    <td>width/height fields</td>
                    <td>int_or_none conversion</td>
                    <td>Visual quality indicator</td>
                </tr>
                <tr>
                    <td>Frame Rate</td>
                    <td>framerate field</td>
                    <td>Integer extraction</td>
                    <td>Smoothness metric</td>
                </tr>
                <tr>
                    <td>Bitrate</td>
                    <td>bitrate field</td>
                    <td>Float conversion (kbps)</td>
                    <td>Compression quality</td>
                </tr>
                <tr>
                    <td>File Size</td>
                    <td>size field</td>
                    <td>Byte count extraction</td>
                    <td>Storage/bandwidth planning</td>
                </tr>
                <tr>
                    <td>Codecs</td>
                    <td>input_metadata</td>
                    <td>Codec parsing function</td>
                    <td>Compatibility assessment</td>
                </tr>
            </tbody>
        </table>

        <h2>üîç Advanced Features</h2>

        <h3>1. Reddit Integration Support</h3>
        <div class="code-block">
            # Prioritize Reddit titles for better context
            title = video.get('reddit_title') or video['title']
        </div>

        <h3>2. Protocol Relative URL Handling</h3>
        <div class="code-block">
            # Ensure proper protocol handling
            'url': self._proto_relative_url(info['url']),
            'thumbnail': self._proto_relative_url(video.get('thumbnail_url')),
        </div>

        <h3>3. Comprehensive Type Safety</h3>
        <div class="code-block">
            # Type-safe conversions throughout
            'width': int_or_none(info.get('width')),
            'height': int_or_none(info.get('height')),
            'filesize': int_or_none(info.get('size')),
            'fps': int_or_none(info.get('framerate')),
            'vbr': float_or_none(info.get('bitrate'), 1000),
            'timestamp': float_or_none(video.get('date_added')),
            'duration': float_or_none(video.get('duration')),
            'view_count': int_or_none(video.get('plays')),
        </div>

        <h2>üéØ Best Practices & Recommendations</h2>

        <div class="info-box">
            <h4>For Developers:</h4>
            <ul>
                <li><strong>API Selection:</strong> Choose internal APIs over public ones when they provide more
                    complete data</li>
                <li><strong>Status Handling:</strong> Implement comprehensive status checking for upload/processing
                    workflows</li>
                <li><strong>Type Safety:</strong> Use robust type conversion functions to handle missing or malformed
                    data</li>
                <li><strong>Codec Intelligence:</strong> Extract and parse codec information for compatibility
                    assessment</li>
                <li><strong>Social Integration:</strong> Prioritize social media titles and context when available</li>
            </ul>
        </div>

        <div class="success-box">
            <h4>Performance Tips:</h4>
            <ul>
                <li>Single API call design minimizes latency and server load</li>
                <li>Efficient JSON parsing with safe nested access patterns</li>
                <li>Protocol-relative URL handling ensures compatibility</li>
                <li>Comprehensive error states provide clear user feedback</li>
                <li>Detailed format metadata enables intelligent client-side selection</li>
            </ul>
        </div>

        <h2>üîÆ Future Considerations</h2>

        <p>Streamable's video hosting technology continues to evolve with several trends emerging:</p>

        <ul>
            <li><strong>Processing Speed:</strong> Faster video processing pipelines reducing upload-to-availability
                time</li>
            <li><strong>Format Diversity:</strong> Support for newer codecs like AV1 and HEVC for better compression
            </li>
            <li><strong>Quality Options:</strong> More granular quality levels and adaptive streaming support</li>
            <li><strong>Social Features:</strong> Enhanced integration with social platforms and communities</li>
            <li><strong>API Evolution:</strong> Potential improvements to public API feature parity</li>
        </ul>

        <div class="highlight">
            <strong>Conclusion:</strong> Streamable's video extraction implementation in yt-dlp demonstrates elegant
            engineering for modern video hosting platforms. The system showcases efficient Ajax API integration,
            sophisticated status handling, comprehensive metadata extraction, and robust error management that serves as
            a model for simple yet powerful video hosting services.
        </div>
    </div>
</body>

</html>